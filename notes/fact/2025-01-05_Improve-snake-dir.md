---
date: 2025-01-05
type: fact
aliases:
  -
hubs:
  - "[[WASM]]"
---

# Improve snake dir

In [[2025-01-04_Change-snake-dir-restriction|this topic]], we refactor the snake game to restrict the snake from turning back on itself. However, the SnakeCell is generated twice in the `change_direction` function and the `step` function when user changes the direction.

```rust
// src/lib.rs

// ...

#[wasm_bindgen]
impl World {

    // ...

    pub fn change_direction(&mut self, direction: Direction) {
        let next_cell = self.gen_next_snake_head(direction);  // when change direction, generate next cell
        if self.snake.body[1].0 == next_cell.0 {
            return;
        }
        self.snake.direction = direction;
    }

    // ...

    pub fn gen_next_snake_head(&self, direction: Direction) -> SnakeCell { ... }
    pub fn step(&mut self) {
        let temp = self.snake.body.clone();
        self.snake.body[0] = self.gen_next_snake_head(self.snake.direction);  // when move, generate next cell
                                                                              // but if change direction is success, why generate again?
        (1..self.snake.body.len()).for_each(|i| self.snake.body[i].0 = temp[i - 1].0);
    }
}

```

We can create a new field of struct `World` to store the next cell generated by `change_direction` function if the direction change is successful. Then, we can use this field in the `step` function to move the snake instead of generating it again.

```rs

// ...

#[wasm_bindgen]
pub struct World {
    width: usize,
    snake: Snake,
    next_cell: Option<SnakeCell>,  // new field to store the next cell
    //         ^^^^^^ because this cell is empty sometimes
}

#[wasm_bindgen]
impl World {
    pub fn new(width: usize, spwan_idx: usize, size: usize) -> Self {
        World {
            width,
            snake: Snake {
                body: (0..size).map(|x| SnakeCell(spwan_idx + x)).collect(),
                direction: Direction::Up,
            },
            next_cell: None,  // give a initial value to new field
        }
    }
    pub fn width(&self) -> usize {
        self.width
    }
    pub fn snake_head_idx(&self) -> usize {
        self.snake.body[0].0
    }
    pub fn change_direction(&mut self, direction: Direction) {
        let next_cell = self.gen_next_snake_head(direction);
        if self.snake.body[1].0 == next_cell.0 {
            return;
        }
        self.next_cell = Some(next_cell);  // when change direction, store the next cell
        self.snake.direction = direction;
    }

    // ...

    pub fn step(&mut self) {
        let temp = self.snake.body.clone();

        // instead of generating next cell directly, now we can check if World has next cell stored
        match &self.next_cell {
            // if has next cell, use it to move the snake head
            Some(cell) => {
                self.snake.body[0] = cell.clone();
                //                       ^^^^^^^^ because self is mut ref, we need to clone it to get the value
                self.next_cell = None; // don't forget to clear the field after use
            }
            // if not, generate next cell as before
            None => self.snake.body[0] = self.gen_next_snake_head(self.snake.direction),
        };
        (1..self.snake.body.len()).for_each(|i| self.snake.body[i].0 = temp[i - 1].0);
    }
}
```

Now, we have improved the code by avoiding generating the same cell twice :)

